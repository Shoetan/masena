// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: author.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAuthor = `-- name: GetAuthor :one
SELECT id, name, bio, created_at, updated_at FROM authors
WHERE id = $1
`

func (q *Queries) GetAuthor(ctx context.Context, id int64) (Author, error) {
	row := q.db.QueryRow(ctx, getAuthor, id)
	var i Author
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAuthorStats = `-- name: GetAuthorStats :one
SELECT 
    a.id, 
    a.name, 
    COUNT(b.id) as total_books, 
    ROUND(AVG(b.price::numeric), 2) as average_price,
    TO_CHAR(MIN(b.published_date), 'YYYY-MM-DD') as earliest_publication,
    TO_CHAR(MAX(b.published_date), 'YYYY-MM-DD') as latest_publication,
    ROUND(SUM(bs.total_revenue), 2) as total_revenue,
    jsonb_object_agg(year::text, book_count)::text AS books_published_per_year
FROM 
    authors a 
LEFT JOIN 
    books b ON a.id = b.author_id 
LEFT JOIN 
    (
        SELECT 
            book_id, 
            COUNT(bs.id) AS total_sales, 
            SUM(b.price::numeric) * COUNT(bs.id) AS total_revenue
        FROM 
            book_sales bs
        JOIN 
            books b ON bs.book_id = b.id
        GROUP BY 
            book_id
    ) bs ON b.id = bs.book_id
LEFT JOIN 
    (
        SELECT 
            EXTRACT(YEAR FROM b.published_date) AS year,
            COUNT(b.id) AS book_count
        FROM 
            books b
        GROUP BY 
            year
    ) yearly_books ON EXTRACT(YEAR FROM b.published_date) = yearly_books.year
WHERE 
    a.id = $1 
GROUP BY 
    a.id, a.name
`

type GetAuthorStatsRow struct {
	ID                    int64
	Name                  string
	TotalBooks            int64
	AveragePrice          pgtype.Numeric
	EarliestPublication   string
	LatestPublication     string
	TotalRevenue          pgtype.Numeric
	BooksPublishedPerYear string
}

func (q *Queries) GetAuthorStats(ctx context.Context, id int64) (GetAuthorStatsRow, error) {
	row := q.db.QueryRow(ctx, getAuthorStats, id)
	var i GetAuthorStatsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TotalBooks,
		&i.AveragePrice,
		&i.EarliestPublication,
		&i.LatestPublication,
		&i.TotalRevenue,
		&i.BooksPublishedPerYear,
	)
	return i, err
}

const listAuthors = `-- name: ListAuthors :many
SELECT id, name, bio, created_at, updated_at FROM authors
ORDER BY name
`

func (q *Queries) ListAuthors(ctx context.Context) ([]Author, error) {
	rows, err := q.db.Query(ctx, listAuthors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Author
	for rows.Next() {
		var i Author
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Bio,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
